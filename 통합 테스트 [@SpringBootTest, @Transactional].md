## 통합 테스트 [@SpringBootTest, @Transactional]

### 1. 개요

스프링 부트를 통해서 개발을 하다보면 TDD(테스트 주도 개발)을 하기 위해서 테스트 코드를 작성해야 한다.
테스트에는 Unit Test(단위 테스트)만 있는 것이 아니라 통합 테스트라는 것도 존재한다.

유닛 테스트는 작게는 메소드 단위로 테스트를 하고 크게는 클래스 단위로도 테스트,
쿼 패키지 단위로도 테스트를 진행할 수 있다.
하지만 유닛 테스트와 통합 테스트는 범위뿐만이 아니라 다른 점에서도 큰 차이를 보이고 있다.

유닛 테스트를 통한 테스트는 Java 기준으로 보면 JVM을 벗어나지 않는 선에서
순수한 자바를 통해 테스트를 진행한다. (물론 JUnit 이라는 프레임워크를 사용하기는 하지만...)
하지만 통합 테스트는 JVM 영역을 벗어나서 DB 쿼리문 전송 및 서버 연결을 통한 JVM 밖의 리소스를 사용하는
테스트가 되어 거대한 테스트가 된다.

주로 유닛 테스트가 주가 되지만 통합 테스트는 한 번쯤은 건드려야 하는 설정이다.
기존의 유닛 테스트로는 DB를 연결하고 서버를 키는 동작을 직접 코드를 통해 설정해주어야 했다면
스프링 부트에서는 @SpringBootTest 라는 어노테이션을 지원함으로써 통합 테스트를 쉽게 구현할 수 있도록
해주었다.

### 2. @SpringBootTest 사용하기

@SpringBootTest는 스프링 부트에서 제공하는 통합 테스트용 테스트 어노테이션이다.
유닛 테스트를 진행할 때는 JUnit의 @Test를 사용했지만
통합 테스트에서는 스프링 부트가 제공하는 @SpringBootTest 어노테이션을 사용한다.

@SpringBootTest 어노테이션을 클래스 단위에 붙이면 그 클래스가 하나의 통합 테스트 클래스가 된다.
유닛 테스트를 하는 클래스의 이름을 [테스트하는 클래스명]+Test 라는 이름으로 지었다면
통합 테스트를 하는 클래스의 이름은 [테스트하는 클래스명]+IntegrationTest 또는 IntTest 라고 이름을 짓는다.

@SpringBootTest 어노테이션을 작성하게 되면 스프링 부트는 자동으로 서버를 작동시키고,
스프링 컨테이너를 작동시키며, 자동으로 DB에 접근하게 된다.

그런데 여기서 문제가 생긴다.
기본적으로 작동시킬 수 있는 모든 기능을 활성화시키고 테스트에 들어가게 되는데
DB에 대해서 접근을 했을 때 DB의 내용이 변경되어서 첫 번째 테스트에서는 성공했지만
두 번째부터는 예외가 발생하는 테스트가 된다면? 그것은 문제가 될 것이다.
그래서 스프링 부트에서는 @Transactional 이라는 어노테이션을 지원한다.

### 3. @Transactional 사용하기

@Transactional 어노테이션을 스프링에서 지원하는 어노테이션으로
원래는 DB의 트랜잭션 기능을 사용하기 위해서 사용하는 어노테이션이었다.
그런데 DB의 트랜잭션 기능을 사용할 뿐만 아니라 @SpringBootTest 어노테이션과 같이 사용하면
DB에 접근했던 SQL문들을 AUTO COMMIT을 하지 않고 ROLLBACK 하는 역할을 한다.

그래서 @SpringBootTest와 @Transactional을 함께 클래스 단위에 작성하면
테스트가 끝난 뒤에도 DB에 무슨 변화가 없는 것을 알 수 있다.

물론 @Transactional 어노테이션을 사용하지 않고도 테스트를 돌릴 수 있다.
하지만 DB에 접근할 경우에는 DB의 내용이 변경될 수 있다는 것을 인지하고 사용해야 한다.