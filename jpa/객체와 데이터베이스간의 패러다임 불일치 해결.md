## 객체와 데이터베이스간의 패러다임 불일치 해결

### 1. 개요

이전에 "JPA를 사용해야 하는 이유"에서 알 수 있듯이 객체와 데이터베이스는 서로 관심사가 다르고
그에 따라서 패러다임이 불일치하다는 문제가 존재한다는 것을 알게 되었다.
그런데 JPA는 어떻게 객체와 데이터베이스간의 패러다임 불일치를 해결했는지에 대해서 알아보겠다.
하지만 여기서는 JPA가 어떻게 내부적으로 동작하는지를 알아서 패러다임 불일치를 해결하는 방법을
알아보는 것이 아니라 객체와 데이터베이스간의 패러다임 불일치가 무엇이 일어나는지에 대해서
코드로 알아보고 그에 대한 문제가 JPA를 통해 해결되었다는 것을 알게 된다.

### 2. 객체 그래프 탐색

객체 그래프를 탐색한다는 것은 객체간의 연관관계가 있을 경우
연관관계가 있는 객체끼리 연결해서 하나의 객체를 가지고 있다면 그 객체를 탐색하여
다른 연관된 객체를 탐색할 수 있어야 한다는 것이다.

이렇게 객체들은 객체간의 연결로 인한 객체 그래프가 존재한다.
그런데 데이터베이스에서 값을 가져와서 객체에 매핑할 경우
객체 그래프를 만들 수가 없는 객체가 되어버린다.

아래는 이에 대한 예제이다.

```java
public class School {
    private int id;	// PRIMARY KEY
    private String name;
    private String location;
    
    // Getter, Setter
}
```

```java
public class Student {
    private int id;	// PRIMARY KEY
    private String name;
    private int age;
    private School school;
    
    // Getter, Setter
}
```

이 예제에 대해서 이해하기 위해서는 먼저 관계형 데이터베이스에 대한 이해가 필요하다.
관계형 데이터베이스는 일대다 상황이 왔을 때 '일' 테이블에 존재하는 PRIMARY KEY를
'다' 테이블이 FOREIGN KEY로 가지고 있게 한다.

그런데 여기서 하나의 학교(School)에는 여러 명의 학생(Student)이 있고
하나의 학생은 하나의 학교에만 들어갈 수 있다라는 명제가 성립하므로
학교와 학생은 일대다 관계를 이룬다.
따라서 '일' 테이블은 School 테이블이 되고 '다' 테이블은 Student 테이블이 된다.
따라서 School의 PRIMARY KEY인 int 타입의 id를 FOREIGN KEY로 받아서 Student 테이블이 가지고 있는다.
그런데 본 객체에서는 int 타입의 id가 아닌 School 타입의 변수가 있는 것을 알 수 있다.

만약 int 타입의 id를 이용해서 FOREIGN KEY를 가지고 있어도 소속된 학교를 알 수는 있겠지만
데이터베이스를 두 번 탐색해야 한다는 문제가 생기고 개발자 입장에서도 직관적이지 않다는 문제가 생긴다.
그리고 위처럼 School 타입으로 되어 있다면 Student 객체를 데이터베이스에서 매핑했을 때
다음과 같이 객체 그래프를 그려 탐색할 수 있다.

```java
Student student = ... 매핑 ...;
String location = student.getSchool().getLocation();
```

하지만 FOREIGN KEY인 id로 되어 있다면 이런식으로 객체 그래프를 그려 탐색할 수가 없다.
그리고 개발자 입장에서는 이 객체 그래프가 여러 개 이어져 있을 때
언제 끊어질지 모르는 입장에서 NULL Safe 하지 않은 객체를 다루는 것은 위험하다.
따라서 JPA에서는 이러한 문제를 해결하기 위해서
객체 그래프를 탐색하여 그 객체를 사용할 때까지 매핑을 미루는 지연로딩 기술을 사용하였다.
이들이 어떻게 구현되는지는 나중에 알게 될 것이다.

### 3. 동일성 비교와 동등성 비교

자바 코드에서 동일성 비교라고 하면 == 기호를 이용하여 비교하는 것을 말하고
동등성 비교라고 하면 equals() 메소드를 이용해서 비교하는 것을 말한다.

동일성 비교를 통해서 비교하면 그 객체의 주소를 비교하므로 완전히 같은 객체가 아니면 false를 리턴한다.
그런데 동등성 비교를 통해서 비교하면 객체 안의 값들이 같다면 true를 리턴하므로
엄연히 이들은 다른 비교라는 것을 알 수 있다.

그런데 SQL문을 이용해서 데이터베이스에 있는 값을 매핑하여 가져오게 되면
같은 PRIMARY KEY를 이용했다고 하더라도 다른 객체가 나올 것이다.
그렇기 때문에 동일성 비교를 하면 false를 리턴하는 문제가 생기는데
이것은 논리적으로 맞지 않다.

왜냐하면 같은 PRIMARY KEY를 이용하여 값을 찾았는데도 불구하고 다른 객체를 리턴한다면
이것은 다른 PRIMARY KEY를 사용한 것과 다름이 없다.
그래서 JPA에서는 같은 값을 넣어서 나온 객체는 무조건 같은 객체로 만든다.
아마 스프링 컨테이너와 같이 컨테이너를 관리하는 것으로 예상이 되는데 확실하지는 않다.