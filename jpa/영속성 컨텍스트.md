## 영속성 컨텍스트

### 1. 개요

영속성 컨텍스트는 EntityManager(엔티티 매니저)가 생성될 때 마다 생성되는 컨텍스트라고 할 수 있다.
하나의 엔티티 매니저는 하나의 영속성 컨텍스트를 가지는데
실제로는 엔티티 매니저가 다른 엔티티 매니저의 영속성 컨텍스트를 건드릴 수도 있다.
일단 이것은 중요하지 않으니 나중에 알아보도록 하겠다.

이렇게 엔티티 매니저가 생성될 때마다 생성되는 영속성 컨텍스트는
데이터베이스의 값을 매핑하기 위해서 만들어진 Entity(엔티티)를 영구적으로 저장하는 환경이라고 할 수 있다.
그리고 스프링 컨테이너가 빈을 관리하는 것처럼 영속성 컨텍스트는 영구 저장되는 엔티티를 관리한다.

### 2. 엔티티의 상태

프로세스에도 상태가 존재하는 것처럼 영속성 컨텍스트가 관리하는 엔티티도 상태가 존재한다.
이런 엔티티는 총 4개의 상태가 존재한다.

#### 2-1. 비영속(New)

비영속 상태는 말 그대로 영속(무한이 속해있는)상태가 아니라는 뜻이므로
생성은 되었으나 영속성 컨텍스트가 관리하지 않는 상태이다.

따라서 생성된 직후 상태(New)가 비영속 상태가 된다.
아직 영속성 컨텍스트의 관리를 받지 않으므로 데이터베이스와는 관련이 없는 객체 본질의 상태가 된다.

#### 2-2. 영속(Managed)

영속은 당연히 비영속의 반대 개념이므로 영속성 컨텍스트에게 관리 받는 엔티티의 상태를 말한다.
일반적인 객체들은 모두 영속성 컨텍스트가 관리하므로 영속 상태라는 것을 알 수 있다.

코드로 확인해보자면 EntityManager.persist() 메소드에 매개변수로 엔티티를 넣었을 경우
그 엔티티는 영속 상태라고 할 수 있다. (persist 메소드는 static 메소드가 아니다. 명시적으로...)

#### 2-3. 준영속(Detached)

준영속 상태는 영속 상태였던 엔티티가 더이상 영속성 컨텍스트의 관리를 받지 않게 되었을 때를 말한다.
준영속 상태가 되기 위해서는 EntityManager의 기능을 멈추어야 하므로
EntityManager.detach(), EntityManager.close(), EntityManager.clear() 메소드를 사용하면 된다.
(물론 모두 static 메소드가 아니라 명시적인 것이다.)

#### 2-4. 삭제(Removed)

삭제 상태는 데이터베이스 상에서 삭제하면 자동으로 삭제 상태가 된다.
엔티티를 제거하는 메소드는 EntityManager.remove() 메소드이며
데이터베이스에서 삭제되면 영속성 컨텍스트에서 관리하지 않고 삭제된다.

### 3. 영속성 컨텍스트의 특징

#### 3-1. 영속성 컨텍스트는 엔티티의 식별자로 구분한다.

영속성 컨텍스트는 관리하는 엔티티를 식별자로 구분하기 때문에
엔티티는 반드시 @Id를 이용해서 PRIMARY KEY(식별자)를 생성해야 한다.
만약 식별자가 존재하지 않는다면 에외가 발생하게 된다.

#### 3-2. 영속성 컨텍스트는 트랜잭션으로 커밋한다.

일반적으로 JPA를 이용하게 되면 모든 데이터베이스와 관련된 로직을 수행할 때는
트랜잭션을 사용하여 수행해야 한다.

그렇기 때문에 영속성 컨텍스트에 엔티티들을 넣고 수정하고 삭제하기 위해서는
당연히 트랜잭션을 수행하여야 한다.
그리고 트랜잭션을 사용하면서 커밋을 해야 실제 데이터베이스에 반영한다.
이러한 작업을 Flush(플러시)라고 한다.

#### 3-3. 영속성 컨텍스트의 장점

##### 1) 1차 캐시

영속성 컨텍스트는 1차 캐시를 내장하고 있다.
1차 캐시는 자바의 컬렉션 프레임워크인 Map으로 이루어져 있는데
기본적으로 식별자를 Key로 두고 그 식별자를 포함하는 엔티티를 Value로 저장한다.
그렇기 때문에 @Id를 이용한 식별자가 존재해야만 영속성 컨텍스트가 관리할 수 있는 것이다.

이러한 1차 캐시가 존재하는 이유는 트랜잭션으로 인해 데이터베이스에 바로 값을 저장 및 수정하는 것이 아니라
모든 로직을 수행한 뒤 한 번에 커밋을 하기 위해서이다.

그리고 영속성 컨텍스트에 1차 캐시를 두면 조회할 때마다 데이터베이스에 접근해야 하는 것과는 달리
1차 캐시에 값이 존재하면 1차 캐시에 존재하는 값을 이용해서 값을 변경할 수 있기 때문에
더 빠른 성능을 보장할 수 있다.

물론 1차 캐시에 원하는 값이 존재하지 않으면 데이터베이스에 접근하여 엔티티를 찾아낸다.

##### 2) 동일성 보장

이전에 "객체와 데이터베이스간의 패러다임 불일치 해결.md"에서 다루었던 것처럼
JPA 즉, 영속성 컨텍스트는 동일성과 동등성을 보장한다.

동일성은 ==을 통해 비교하고 동등성은 equals() 메소드를 이용해서 비교한다.
그런데 일반적으로 SQL문을 이용해 엔티티를 가져오게 되면 == 즉, 동일성 비교를 했을 때 false가 리턴된다.
하지만 영속성 컨텍스트가 관리하는 엔티티는 동일성을 유지하게 해준다.
따라서 같은 식별자를 매개변수로 넣으면 같은 엔티티가 리턴되게 되어
동일성 비교를 했을 때 true가 리턴될 수 있도록 지원한다.

##### 3) 트랜잭션을 지원하는 쓰기 지연

위에서 영속성 컨텍스트는 트랜잭션 안에서만 동작이 가능하다고 했었다.
따라서 트랜잭션을 지원하면서 쓰기 지연이라는 것을 지원하는데

쓰기 지연이란 엔티티의 변경을 바로 데이터베이스에 저장하지 않고 1차 캐시에 저장하는 것처럼
그 때 사용된 쿼리문을 쓰기 지연 SQL 저장소에 저장했다가 트랜잭션이 끝났을 때
한 번에 쿼리문을 데이터베이스에 날리는 것을 말한다.

이런 쓰기 지연을 통해서 여러 번 데이터베이스에 접근해서 실행해야 했던 쿼리문을
한 번에 날리면 데이터베이스의 성능에도 좋다.

##### 4) 변경 감지

변경 감지는 우리가 JPA를 사용하면서 UPDATE 문을 작성할 필요가 없는 이유를 설명하준다.
쉽게 생각하면 엔티티가 변경된 것을 감지하여 감지되었을 때
그 변경을 쿼리문으로 작성해준다고 생각하면 되는데

더 자세하게 알고 있는 것이 좋다.
일단 영속성 컨텍스트에 관리되고 있는 엔티티는 이를 복사한 스냅샷을 같이 가지고 있다.
이 상태로 트랜잭션 안에서 여러 로직이 수행되게 되고
트랜잭션이 끝나면 commit() 메소드를 통해 커밋을 하게 된다.
그러면 영속성 컨텍스트는 스냅샷과 여러 로직이 수행된 뒤의 엔티티를 비교하여
어떠한 변경점이 있는지 확인하고 그 변경점을 토대로 UPDATE 쿼리문을 작성한다.
작성된 쿼리문을 쓰기 지연 SQL 저장소에 저장하고
최종적으로 쓰기 지연 SQL 저장소에 있는 쿼리문이 날아가 트랜잭션을 커밋하게 된다.

이런식으로 내부적으로는 여러 UPDATE 문이 동작하고 있지만
JPA를 사용하는 입장에서는 영속성 컨텍스트가 변경을 감지하여
변경을 하는 것으로 보이는 것을 변경 감지라고 한다.

##### 5) 지연 로딩

영속성 컨텍스트가 관리하는 엔티티들은 지연 로딩을 통해 사용된다.
이것은 전에도 언급했듯이 엔티티가 사용되기 전까지는 객체 그래프 탐색을 위해서
SELECT 문을 지연하는 것을 말한다.